<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>安平：五段被抹去的記憶</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            font-family: "Noto Serif TC", "Songti TC", serif;
            background-color: #000;
            color: #ddd;
        }

        /* --- 序章故事螢幕 --- */
        #intro-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
            transition: opacity 1.5s ease-in-out;
        }

        .story-line {
            font-size: 1.2rem;
            margin-bottom: 20px;
            opacity: 0;
            transform: translateY(10px);
            transition: all 1s ease-out;
            color: #f0f0f0;
            letter-spacing: 2px;
        }

        .story-line.visible {
            opacity: 1;
            transform: translateY(0);
        }

        #start-btn {
            margin-top: 40px;
            padding: 12px 30px;
            background: transparent;
            border: 1px solid #e15f41;
            color: #e15f41;
            font-family: "Noto Serif TC", serif;
            font-size: 1rem;
            cursor: pointer;
            opacity: 0;
            transition: all 0.5s;
            letter-spacing: 3px;
        }

        #start-btn:hover {
            background: #e15f41;
            color: #000;
            box-shadow: 0 0 15px rgba(225, 95, 65, 0.5);
        }

        /* --- 遊戲 UI --- */
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            opacity: 0;
            transition: opacity 1.5s;
        }

        .header {
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.9), transparent);
            padding: 30px;
            pointer-events: auto;
        }

        h1 {
            margin: 0;
            font-size: 28px;
            color: #e15f41;
            text-shadow: 0 0 10px rgba(225, 95, 65, 0.3);
            font-weight: 700;
        }

        .chapter-tag {
            display: inline-block;
            border: 1px solid #aaa;
            color: #aaa;
            padding: 2px 8px;
            font-size: 12px;
            margin-bottom: 5px;
            letter-spacing: 1px;
        }

        .description {
            margin-top: 15px;
            font-size: 15px;
            color: #ccc;
            max-width: 600px;
            line-height: 1.8;
            text-shadow: 1px 1px 2px black;
            border-left: 2px solid #e15f41;
            padding-left: 15px;
        }

        .footer {
            padding: 20px;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.9), transparent);
            pointer-events: auto;
            display: flex;
            justify-content: center;
            /* 改為置中 */
            align-items: flex-end;
        }

        /* 轉場與通知 */
        .fade-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.8s ease-in-out;
            z-index: 100;
        }
    </style>
</head>

<body>

    <div id="intro-screen">
        <div class="story-line">歷史，不會自己說話。</div>
        <div class="story-line">它只會在被遺忘之前，把真相藏給願意尋找的人。</div>
        <div class="story-line">這裡，藏著五段被抹去的記憶。</div>
        <div class="story-line">若你願意，就從這裡開始。</div>
        <button id="start-btn" onclick="enterGame()">開始尋找</button>
    </div>

    <div id="fade-overlay" class="fade-overlay"></div>

    <div id="ui-container">
        <div class="header">
            <div class="chapter-tag" id="location-chapter">序章</div>
            <h1 id="location-title">載入中...</h1>
            <div id="location-desc" class="description">...</div>
        </div>

        <div class="footer">
            <div style="font-size: 12px; color: #888; letter-spacing: 1px;">
                拖曳視角 • 點擊箭頭移動
            </div>
            <!-- Video Control Button (Hidden by default) -->
            <button id="video-btn"
                style="display:none; margin-left: 20px; padding: 8px 16px; background: rgba(225, 95, 65, 0.8); border: none; color: white; cursor: pointer;">
                播放影片
            </button>
        </div>
    </div>

    <!-- Hidden Video Element -->
    <video id="video-player" loop crossOrigin="anonymous" playsinline style="display:none;">
        <source src="" type="video/mp4">
    </video>

    <!-- Background Music -->
    <audio id="bg-music" loop>
        <source src="bgmusic.m4a" type="audio/mp4">
    </audio>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 故事化地點設定 (The Five Memories) ---
        const LOCATIONS = {
            fort: {
                id: 'fort',
                chapter: "記憶之一：權力的紅磚",
                title: "安平古堡 (The Old Fort)",
                desc: "熱蘭遮城的殘壁斷垣。荷蘭人曾在此建立統治，鄭成功曾在此改變歷史。紅磚縫隙裡，藏著多少次政權更迭的嘆息？",
                themeColor: 0x8B0000,
                bgType: 'grid',
                defaultImage: 'https://i.imgur.com/3ZW3eI2.jpeg',
                // video: 'path/to/your/video.mp4', // TODO: Replace with your actual video file path
                video: '1.mp4',
                links: [
                    { to: 'street', label: "往 喧囂的殘響 (老街)", pos: { x: 40, y: -5, z: -40 } },
                    { to: 'treehouse', label: "往 被吞噬的屋舍 (樹屋)", pos: { x: -40, y: -5, z: 10 } }
                ]
            },
            street: {
                id: 'street',
                chapter: "記憶之二：喧囂的殘響",
                title: "安平老街 (Old Street)",
                desc: "台灣第一街。曾經的貿易樞紐，如今充滿了遊客的喧鬧。但在這熱鬧之下，你是否聽得見三百年前商賈的叫賣聲？",
                themeColor: 0xDAA520,
                bgType: 'grid',
                defaultImage: 'https://i.imgur.com/x2oVkCl.jpeg',
                video: '2.mp4',

                links: [
                    { to: 'fort', label: "回 權力的紅磚 (古堡)", pos: { x: -40, y: -5, z: 15 } },
                    { to: 'tait', label: "往 洋人的足跡 (洋行)", pos: { x: 30, y: -5, z: -40 } }
                ]
            },
            treehouse: {
                id: 'treehouse',
                chapter: "記憶之三：被吞噬的屋舍",
                title: "安平樹屋 (Tree House)",
                desc: "人去樓空，自然接管了一切。榕樹的氣根穿透了牆面，屋即是樹，樹即是屋。這是大自然對人類建築最溫柔也最殘酷的擁抱。",
                themeColor: 0x2E8B57,
                bgType: 'grid',
                defaultImage: 'https://i.imgur.com/C4JHpXs.jpeg',
                video: '3.mp4',
                links: [
                    { to: 'fort', label: "回 權力的紅磚", pos: { x: 40, y: -5, z: 20 } },
                    { to: 'tait', label: "旁即 洋人的足跡", pos: { x: -30, y: -5, z: -30 } }
                ]
            },
            tait: {
                id: 'tait',
                chapter: "記憶之四：洋人的足跡",
                title: "德記洋行 (Tait & Co.)",
                desc: "純白的拱廊，曾經堆滿了茶葉與樟腦。這些來自遠方的商人，在此留下了優雅的建築，隨後又在歷史的浪潮中撤離。",
                themeColor: 0xE0FFFF,
                bgType: 'grid',
                defaultImage: 'https://i.imgur.com/VO0xqIo.jpeg',
                video: '4.mp4',
                links: [
                    { to: 'treehouse', label: "往 被吞噬的屋舍", pos: { x: -30, y: -5, z: 20 } },
                    { to: 'street', label: "往 喧囂的殘響", pos: { x: 30, y: -5, z: 30 } },
                    { to: 'sunset', label: "往 終結的邊界 (觀夕)", pos: { x: 0, y: 0, z: -50 } }
                ]
            },
            sunset: {
                id: 'sunset',
                chapter: "記憶之五：終結的邊界",
                title: "觀夕平台 (The End)",
                desc: "陸地的盡頭，海洋的起點。所有的歷史、貿易、爭戰，最終都會像這落日一樣，沉入黑水溝的深處，歸於平靜。",
                themeColor: 0xFF4500,
                bgType: 'grid',
                defaultImage: 'https://i.imgur.com/aijduvF.jpeg',
                video: '5.mp4',
                links: [
                    { to: 'tait', label: "回頭是岸 (回市區)", pos: { x: 0, y: -5, z: 40 } }
                ]
            }
        };

        // --- 全域變數 ---
        let scene, camera, renderer, controls;
        let raycaster, mouse;
        let currentSphere;
        let sprites = [];
        let currentId = 'fort';
        const textureLoader = new THREE.TextureLoader();
        let videoElement, videoTexture;

        // 綁定給 HTML 使用
        window.enterGame = enterGame;

        // --- 序章動畫 ---
        window.onload = function () {
            const lines = document.querySelectorAll('.story-line');
            lines.forEach((line, index) => {
                setTimeout(() => {
                    line.classList.add('visible');
                }, 800 * (index + 1));
            });

            setTimeout(() => {
                document.getElementById('start-btn').style.opacity = 1;
            }, 800 * (lines.length + 1) + 500);

            initThreeJS(); // 預先載入 3D，但在背景執行

            // Setup video button
            const videoBtn = document.getElementById('video-btn');
            videoBtn.addEventListener('click', () => {
                if (videoElement.paused) {
                    videoElement.play();
                    videoBtn.innerText = "暫停影片";
                } else {
                    videoElement.pause();
                    videoBtn.innerText = "播放影片";
                }
            });

            // Try to play music on load
            const bgMusic = document.getElementById('bg-music');
            bgMusic.volume = 0.5;
            bgMusic.play().catch(error => {
                console.log("Autoplay prevented by browser policy. Music will start on interaction.");
            });
        };

        function enterGame() {
            const intro = document.getElementById('intro-screen');
            const ui = document.getElementById('ui-container');

            // Ensure music is playing
            const bgMusic = document.getElementById('bg-music');
            if (bgMusic.paused) {
                bgMusic.play().catch(e => console.error("Music play failed:", e));
            }

            intro.style.opacity = 0;
            setTimeout(() => {
                intro.style.display = 'none';
                ui.style.opacity = 1;
                // 開始渲染迴圈
                animate();
            }, 1500);
        }

        // --- Three.js 核心 ---
        function initThreeJS() {
            const container = document.body;
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 0.1);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableZoom = false;
            controls.rotateSpeed = -0.5;

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Init Video
            videoElement = document.getElementById('video-player');
            videoTexture = new THREE.VideoTexture(videoElement);
            videoTexture.colorSpace = THREE.SRGBColorSpace;

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('pointerdown', onPointerDown);

            loadLocation('fort');
        }

        function createGridTexture(colorHex) {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // 深色背景，營造神秘感
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, 1024, 512);

            const color = new THREE.Color(colorHex);

            // 隨機雜訊 (模擬記憶模糊)
            for (let i = 0; i < 5000; i++) {
                ctx.fillStyle = `rgba(${color.r * 255}, ${color.g * 255}, ${color.b * 255}, ${Math.random() * 0.1})`;
                ctx.fillRect(Math.random() * 1024, Math.random() * 512, 2, 2);
            }

            // 網格線
            ctx.strokeStyle = `rgba(${color.r * 255}, ${color.g * 255}, ${color.b * 255}, 0.3)`;
            ctx.lineWidth = 1;
            const gridSize = 64;
            for (let x = 0; x <= 1024; x += gridSize) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, 512); ctx.stroke();
            }
            for (let y = 0; y <= 512; y += gridSize) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(1024, y); ctx.stroke();
            }

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        function loadLocation(id) {
            currentId = id;
            const data = LOCATIONS[id];

            document.getElementById('location-chapter').innerText = data.chapter;
            document.getElementById('location-title').innerText = data.title;
            document.getElementById('location-desc').innerText = data.desc;

            // Reset video state
            videoElement.pause();
            videoElement.src = "";
            document.getElementById('video-btn').style.display = 'none';

            if (currentSphere) scene.remove(currentSphere);
            sprites.forEach(s => scene.remove(s));
            sprites = [];

            let material;

            // 優先檢查是否有影片
            if (data.video && data.video !== '') {
                videoElement.src = data.video;
                videoElement.play().then(() => {
                    document.getElementById('video-btn').innerText = "暫停影片";
                }).catch(e => {
                    console.log("Autoplay blocked, waiting for user interaction", e);
                    document.getElementById('video-btn').innerText = "播放影片";
                });
                document.getElementById('video-btn').style.display = 'block';

                material = new THREE.MeshBasicMaterial({ map: videoTexture });
                // 影片通常需要水平翻轉
                // geometry scale -1, 1, 1 已經做了翻轉，這裡不需要額外處理，除非影片本身是反的
            }
            // 其次檢查預設圖片
            else if (data.defaultImage && data.defaultImage !== '') {
                const texture = textureLoader.load(data.defaultImage);
                texture.colorSpace = THREE.SRGBColorSpace;
                material = new THREE.MeshBasicMaterial({ map: texture });
            }
            // 最後使用網格
            else {
                const texture = createGridTexture(data.themeColor);
                material = new THREE.MeshBasicMaterial({ map: texture });
            }

            const geometry = new THREE.SphereGeometry(60, 60, 40);
            geometry.scale(-1, 1, 1);
            currentSphere = new THREE.Mesh(geometry, material);
            scene.add(currentSphere);

            if (data.links) {
                data.links.forEach(link => {
                    createSprite(link, data.themeColor);
                });
            }
        }

        function createSprite(linkData, themeColorHex) {
            const canvas = document.createElement('canvas');
            canvas.width = 300;
            canvas.height = 100;
            const ctx = canvas.getContext('2d');

            const color = new THREE.Color(themeColorHex);
            const colorStr = `rgb(${color.r * 255},${color.g * 255},${color.b * 255})`;

            // 邊框風格
            ctx.strokeStyle = colorStr;
            ctx.lineWidth = 4;
            ctx.strokeRect(10, 10, 280, 60);
            ctx.fillStyle = "rgba(0,0,0,0.7)";
            ctx.fillRect(10, 10, 280, 60);

            // 文字
            ctx.font = "24px 'Noto Serif TC'";
            ctx.fillStyle = "#fff";
            ctx.textAlign = "center";
            ctx.fillText(linkData.label, 150, 50);

            // 下方指標
            ctx.beginPath();
            ctx.fillStyle = colorStr;
            ctx.moveTo(140, 75);
            ctx.lineTo(160, 75);
            ctx.lineTo(150, 95);
            ctx.fill();

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, depthTest: false });
            const sprite = new THREE.Sprite(material);

            sprite.position.set(linkData.pos.x, linkData.pos.y, linkData.pos.z);
            sprite.scale.set(10, 3.3, 1);
            sprite.userData = { targetId: linkData.to };

            scene.add(sprite);
            sprites.push(sprite);
        }

        function onPointerDown(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(sprites);

            if (intersects.length > 0) {
                const targetId = intersects[0].object.userData.targetId;
                const overlay = document.getElementById('fade-overlay');
                overlay.style.opacity = 1;
                setTimeout(() => {
                    loadLocation(targetId);
                    overlay.style.opacity = 0;
                }, 800);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>